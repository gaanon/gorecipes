# Plan: Admin Recipe Import Feature

**Last Updated:** 19/05/2025

**Status:** Approved

## 1. Overall Goal

To allow an administrator to import recipes into the system by uploading a JSON file. The JSON file format must match the one generated by the existing recipe export feature.

## 2. Key Decisions & Behaviors

*   **Input Format:** A JSON file containing an array of recipe objects. Each recipe object should conform to the `models.Recipe` structure.
*   **File Validation:**
    *   If the uploaded file is not valid JSON, the import process will stop immediately, and an error message will be displayed to the user.
*   **Recipe Object Validation:**
    *   **Required Fields (for successful unmarshalling and basic sense):** `ID` (non-empty string), `Name` (non-empty string), `Method` (non-empty string), `Ingredients` (array of strings, can be empty), `CreatedAt` (valid time.Time), `UpdatedAt` (valid time.Time).
    *   If a recipe object in the JSON array is malformed (e.g., missing a required field, or a field has an incorrect data type that prevents unmarshalling), it will be skipped. A count of skipped malformed recipes will be reported.
*   **Duplicate Handling (Based on `ID`):**
    *   If a recipe in the import file has an `ID` that already exists in the database, that recipe will be skipped. A count of skipped duplicate recipes will be reported.
*   **`PhotoFilename` Handling:** The `photo_filename` field from the imported recipe objects will be ignored. Image management is a separate process. If an imported recipe has no photo linked via other means, the Pexels fallback will apply if that logic is triggered (e.g. on view or if explicitly run).
*   **`FilterableIngredientNames` Handling:** If this field is present in the imported JSON, it will be saved. If absent, it will be an empty slice for the imported recipe. This field is typically populated by a separate process or upon recipe creation/update.
*   **Timestamps (`CreatedAt`, `UpdatedAt`):** These will be taken directly from the JSON file. This means imported recipes will retain their original creation and update timestamps.

## 3. Backend API (`POST /api/v1/admin/import`)

*   **Route:** `POST /api/v1/admin/import`
*   **Request:** `multipart/form-data` containing a single file field (e.g., `recipes_file`).
*   **Handler Location:** A new handler, e.g., `ImportRecipes` in `backend/internal/handlers/admin_handlers.go` (or a new file like `import_handler.go`).
*   **Response:** JSON object detailing the import results:
    ```json
    {
      "total_recipes_in_file": 0,
      "successfully_imported_count": 0,
      "skipped_duplicate_count": 0,
      "skipped_malformed_count": 0,
      "error_message": "" // General error message if file is invalid, etc.
    }
    ```
    (Note: `error_message` would be populated for file-level errors. Individual recipe errors contribute to counts.)

## 4. Backend Logic (`ImportRecipes` Handler)

1.  **Receive File:** Get the uploaded file from the `multipart/form-data` request. Ensure a file was actually provided.
2.  **Read File Content:** Read the entire file into a byte slice.
3.  **Initial JSON Validation:** Attempt to unmarshal the byte slice into `var recipes []models.Recipe`.
    *   If this fails, return an HTTP 400 Bad Request with `{"error_message": "Invalid JSON file format."}`.
4.  **Process Recipes:** Iterate through the unmarshalled `recipes` slice.
    *   Initialize counters: `successfully_imported_count`, `skipped_duplicate_count`, `skipped_malformed_count`.
    *   `total_recipes_in_file = len(recipes)`.
    *   For each `recipeFromFile` in the array:
        *   **Basic Validation:**
            *   Check if `recipeFromFile.ID` is empty. If so, increment `skipped_malformed_count`, continue.
            *   Check if `recipeFromFile.Name` is empty. If so, increment `skipped_malformed_count`, continue.
            *   Check if `recipeFromFile.Method` is empty. If so, increment `skipped_malformed_count`, continue.
            *   Check if `recipeFromFile.CreatedAt.IsZero()` or `recipeFromFile.UpdatedAt.IsZero()`. If so, increment `skipped_malformed_count`, continue.
            *   (Ingredients can be an empty slice).
        *   **Check for Duplicates:** Call `database.RecipeExists(recipeFromFile.ID)`.
            *   If error during DB check: Log server error, increment `skipped_malformed_count` (treating as a processing failure for this item), continue.
            *   If recipe exists: Increment `skipped_duplicate_count`, continue.
        *   **Prepare for Save:**
            *   Create a new `models.Recipe` instance to save, copying fields from `recipeFromFile`.
            *   Explicitly set `PhotoFilename` to `""` (empty string) on the new instance.
            *   Ensure `FilterableIngredientNames` is an empty slice if `recipeFromFile.FilterableIngredientNames` is nil.
            *   The `ID`, `Name`, `Ingredients`, `Method`, `CreatedAt`, `UpdatedAt` are taken from `recipeFromFile`.
        *   **Save to Database:** Call `database.SaveRecipe(&recipeToSave)`.
            *   If save fails: Log server error, increment `skipped_malformed_count`, continue.
            *   If save succeeds: Increment `successfully_imported_count`.
5.  **Return Response:** Send an HTTP 200 OK with the JSON response object containing all counts.

## 5. New Database Functions (Potential)

*   `database.RecipeExists(id string) (bool, error)`: Optimized to check for key existence without fetching the whole item. This would likely involve a `txn.Get(key)` and checking if `err == badger.ErrKeyNotFound`.
*   The existing `database.SaveRecipe(recipe *models.Recipe)` should be suitable if it correctly creates a new entry using the provided `recipe.ID` as the key.

## 6. Frontend UI (Svelte)

*   **Admin Home Page (`/admin` - `frontend/src/routes/admin/+page.svelte`):**
    *   Add a new link/card for "Import Recipes" navigating to `/admin/import`.
*   **Import Recipes Page (New Route: `/admin/import` - `frontend/src/routes/admin/import/+page.svelte`):**
    *   **File Input:** A standard `<input type="file" accept=".json" bind:this={fileInput}>`.
    *   **Button:** "Upload and Import Recipes", disabled if no file selected or if an import is in progress.
    *   **Feedback Area:** To display:
        *   Status messages (e.g., "Uploading...", "Processing file...", "Import complete!").
        *   Success summary: "Total recipes in file: X. Successfully imported: Y. Duplicates skipped: Z. Malformed/Skipped: W."
        *   Error messages: "Please select a JSON file.", "Invalid JSON file format.", "Upload failed due to server error.", etc.

## 7. Workflow Diagram

```mermaid
graph TD
    A[User navigates to /admin/import] --> B{Selects JSON file};
    B --> C[Clicks "Upload and Import Recipes"];
    C --> D{Frontend: POST /api/v1/admin/import with file};
    D --> E{Backend: Receives file};
    E --> F{Is file valid JSON array of recipes?};
    F -- No --> G[Return "Invalid JSON file format." error to Frontend];
    F -- Yes --> H[Backend: For each recipe in file... (total_recipes_in_file = N)];
    H --> VAL1{Basic Validation (ID, Name, Method, Timestamps non-empty/zero)?};
    VAL1 -- No (Malformed) --> J[Increment skipped_malformed_count, Next recipe];
    VAL1 -- Yes --> K{DB: Recipe ID already exists?};
    K -- Yes (Duplicate) --> L[Increment skipped_duplicate_count, Next recipe];
    K -- No --> M{Backend: Prepare recipe object (clear PhotoFilename, ensure FilterableIngredientNames slice)};
    M --> N{DB: SaveRecipe};
    N -- Success --> O[Increment successfully_imported_count, Next recipe];
    N -- Failure (DB Error) --> P[Increment skipped_malformed_count, Log server error, Next recipe];
    H -- Iteration Done --> Q{Backend: Compile result counts};
    Q --> R[Return JSON response with counts to Frontend];
    R --> S[Frontend: Display summary/errors to User];
    G --> S;
```

## 8. Security Considerations

*   The `/api/v1/admin/import` endpoint must be protected by the same admin authentication/authorization as other admin routes (assuming such auth is implemented).
*   Limit file upload size if necessary via server configuration (e.g., Nginx or Gin middleware) to prevent resource exhaustion.
*   The JSON parsing and subsequent processing should be robust against malformed data.

## 9. `models.Recipe` Structure (for reference)

```go
type Recipe struct {
	ID                        string    `json:"id"`
	Name                      string    `json:"name"`
	Ingredients               []string  `json:"ingredients"`
	FilterableIngredientNames []string  `json:"filterable_ingredient_names,omitempty"`
	Method                    string    `json:"method"`
	PhotoFilename             string    `json:"photo_filename,omitempty"`
	CreatedAt                 time.Time `json:"created_at"`
	UpdatedAt                 time.Time `json:"updated_at"`
}